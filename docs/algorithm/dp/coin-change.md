# 硬币找零问题

## 介绍

硬币找零问题是一种经典的动态规划问题，描述如下：
给定不同面值的硬币和一个总金额，计算凑成总金额所需的最少硬币数。如果金额无法凑成，返回 `-1`。

## 问题定义

1. 输入：

- 一个数组`coins`，表示不同面值的硬币。
- 一个整数`amount`，表示总金额 。

1. 输出：

- 一个整数，表示凑成总金额所需的最少硬币数。如果无法凑成，返回 `-1`。

## 解决方法

### 动态规划

#### 状态定义

令$dp[i]$表示凑成金额$i$所需的最少硬币数。

#### 状态转移方程

- 如果选择硬币`coin`，则：$dp[i] = \min(dp[i], dp[i - coin] + 1)$
- 即取当前硬币时的硬币数和不取当前硬币的最小值。

#### 初始条件

- $dp[0] = 0$ ：凑成金额 0 不需要任何硬币。
- $dp[i] = \infty$（或一个大数）：表示尚未计算的金额$i$。

#### 最终结果

如果$dp[amount]$仍是$\infty$，说明无法凑成金额，返回`-1`；否则返回$dp[amount]$。

## 代码

动态规划解法 - 时间复杂度: $O(n \times \text{amount})$

::: code-group
<<< ../../../src/dp/coin-change.ts

<<< ../../../src/dp/coin-change.test.ts
:::

## 源码

<SourceGroup/>

## 算法复杂度

- 时间复杂度：$O(n \times \text{amount})$，其中$n$是硬币种类数，每个硬币会遍历$\text{amount}$。
- 空间复杂度：$O(\text{amount})$，动态规划数组的大小为$\text{amount} + 1$。

## 应用场景

1. 支付系统：计算最优支付方案。
2. 资源分配：在资源有限的情况下实现目标值。
3. 货币兑换：寻找最优组合来兑换金额。

## 总结

硬币找零问题是一个动态规划经典问题，通过构建递推关系，可以有效地解决问题。尽管如此，对于较大的金额和硬币种类数，该算法的性能可能会下降，可以考虑使用贪心算法（适用于满足最优子结构的场景）或启发式方法进一步优化。
