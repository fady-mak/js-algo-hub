# 堆排序

## 介绍

堆排序（Heap Sort）是一种基于堆数据结构的排序算法，具有$O(n \log n)$的时间复杂度。堆是一种特殊的完全二叉树，分为**最大堆**和**最小堆**：

- **最大堆**：每个节点的值都大于或等于其子节点的值。
- **最小堆**：每个节点的值都小于或等于其子节点的值。

> [!TIP] 堆排序通过以下步骤实现：
>
> 1. **构建堆**：将无序数组构建为最大堆。
> 2. **排序过程**：
>
> - 交换堆顶元素（最大值）和末尾元素。
> - 将堆的长度减 1，重新调整堆，使剩余元素满足最大堆性质。
>
> 3. **重复步骤 2**，直到所有元素有序。

## 代码

::: code-group
<<< ../../../src/sorting/heap-sort.ts

<<< ../../../src/sorting/heap-sort.test.ts
:::

## 源码

<SourceGroup/>

## 注意点

1. **时间复杂度**：

   - 最坏情况时间复杂度：$O(n log n)$，堆的调整过程涉及 $O(log n)$ 的操作，而调整次数为$O(n)$。
   - 最好情况时间复杂度：$O(n log n)$，即使数据已经有序，仍需进行堆的构建和调整。
   - 平均时间复杂度：$O(n log n)$。

2. **空间复杂度**：

   - 堆排序是一种原地排序算法，空间复杂度为 $O(1)$。

3. **稳定性**：

   - 堆排序是不稳定的排序算法，因为在堆调整过程中，元素的相对顺序可能会改变。

4. **优化**：

   - **避免重复调整**：在某些场景下可以通过标记或跳跃优化调整步骤。
   - **改进堆构建**：使用自底向上的方法更高效地构建堆。

5. **适用范围**：
   - 堆排序适合需要较低空间复杂度和对稳定性没有严格要求的场景。

## 使用场景

堆排序常用于以下场景：

1. **对空间复杂度要求高的场景**：

   - 堆排序无需额外空间，适合内存资源有限的系统。

2. **优先队列实现**：

   - 堆排序的堆构建过程与优先队列的操作密切相关。

3. **对性能要求较高的通用排序**：
   - 虽然性能不如快速排序，但在某些最坏情况下比快速排序更稳定。

## 总结

堆排序是一种高效的比较排序算法，具有 $O(n log n)$ 的时间复杂度和$O(1)$的空间复杂度。尽管它不稳定，但因其良好的性能和较低的空间占用，广泛应用于对内存敏感的环境或需要优先队列支持的系统中。
