# 计数排序

## 介绍

计数排序（Counting Sort）是一种非比较排序算法，它通过计数数组中每个元素的出现次数，确定每个元素在排序后数组中的位置，从而实现排序。计数排序适用于数据范围较小的正整数或可以映射到正整数的数据。

> [!TIP] 计数排序的基本思想如下：
>
> 1. 找出数组中的最大值和最小值，确定计数数组的大小。
> 2. 创建一个计数数组，记录每个元素的出现次数。
> 3. 对计数数组进行累加，确定每个元素在排序后数组中的位置。
> 4. 根据计数数组，将元素放到输出数组中，形成有序数组。

计数排序的时间复杂度为 $O(n + k)$，其中 $n$ 是输入数组的大小，$k$ 是数组中元素的最大值与最小值之间的范围。

## 代码

::: code-group
<<< ../../../src/sorting/counting-sort.ts

<<< ../../../src/sorting/counting-sort.test.ts
:::

## 源码

<SourceGroup/>

## 注意点

1. **时间复杂度**：

   - 最坏情况时间复杂度：$O(n + k)$，其中$n$为数组长度，$k$ 为数组中元素范围。
   - 最好情况时间复杂度：$O(n + k)$，同最坏情况。
   - 平均时间复杂度：$O(n + k)$。

2. **空间复杂度**：

   - 需要额外的计数数组和结果数组，空间复杂度为 $O(n + k)$。

3. **稳定性**：

   - 计数排序是稳定的排序算法，因为它按顺序放置相同元素，不会改变相对位置。

4. **限制**：

   - 仅适用于正整数或可映射到正整数的数组。
   - 当数组元素范围 $k$ 远大于数组长度 $n$ 时，计数排序的效率会下降。

5. **优化**：
   - 通过优化计数数组的空间使用，减少浪费。
   - 对非整数数据，可以将数据映射为整数（如浮点数通过缩放变为整数）。

## 使用场景

计数排序适合以下场景：

1. **数据范围较小的排序**：

   - 如学生成绩、年龄等值域较小的数据。

2. **需要稳定排序的场景**：

   - 如排序后仍需保留相同值元素的相对顺序。

3. **对时间复杂度要求较高的场景**：
   - 当数据范围较小且稳定性重要时，计数排序是一种高效选择。

## 总结

计数排序是一种简单高效的非比较排序算法，特别适合处理正整数或值域较小的数据。虽然在某些场景下受到数据范围的限制，但其稳定性和高效性使得它在特定领域（如数据统计和分类问题）具有不可替代的优势。
