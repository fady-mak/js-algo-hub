# 冒泡排序

## 介绍

冒泡排序（Bubble Sort）是一种简单的排序算法，它通过重复地遍历待排序的元素，比较相邻元素并交换位置，直到所有元素按照指定顺序排序。该算法得名于“气泡”现象，因为每一轮遍历都会将最大的元素“冒泡”到数组的末尾。

> [!TIP] 冒泡排序的基本思想如下：
>
> 1. 从数组的第一个元素开始，比较相邻的两个元素。
> 2. 如果当前元素比下一个元素大，则交换它们。
> 3. 重复上述过程，直到数组的末尾。此时最大的元素被“冒泡”到数组的末尾。
> 4. 每完成一轮遍历，数组中剩余的部分会减少一个元素，因为这个部分已经排序好了。
> 5. 重复这一过程，直到整个数组有序。

## 代码

::: code-group
<<< ../../../src/sorting/bubble-sort.ts

<<< ../../../src/sorting/bubble-sort.test.ts
:::

## 源码

<SourceGroup/>
## 注意点

1. **时间复杂度**：

   - 最坏情况时间复杂度：$O(n^2)$。当数组是逆序时，冒泡排序需要进行最多的比较和交换操作。
   - 最好情况时间复杂度：$O(n)$。当数组已经是有序的时，冒泡排序只需要一次遍历，通过交换标志 `swapped` 判断是否提前结束。
   - 平均时间复杂度：$O(n^2)$。

2. **空间复杂度**：

   - 冒泡排序是就地排序算法，空间复杂度是 $O(1)$，因为它只需要常数的额外空间来存储临时交换变量。

3. **稳定性**：

   - 冒泡排序是稳定的排序算法。因为它只交换相邻的元素，如果两个元素相等，它们的相对顺序不会被改变。

4. **优化**：

   - 在某些情况下，可以通过引入 `swapped` 标志来优化冒泡排序。如果一轮遍历没有交换元素，说明数组已经有序，可以提前终止排序过程，减少不必要的计算。

5. **不适用于大数据量**：
   - 由于冒泡排序的时间复杂度是 $O(n^2)$，对于大量数据的排序效率较低，不适合用在数据量很大的场景。

## 使用场景

尽管冒泡排序的效率相对较低，但它在一些特殊场景下仍然有应用价值：

1. **小规模数据集**：

   - 对于数据量较小（例如几十个元素）的数组，冒泡排序由于其简单易实现的特性，仍然可以使用。

2. **学习和理解排序算法**：

   - 由于冒泡排序是最简单的排序算法之一，它通常用于教学和学习目的，帮助学生理解排序的基本原理。

3. **需要稳定排序的场景**：

   - 冒泡排序是稳定的排序算法。在一些对稳定性有要求的场合（例如按多个属性排序时），如果数据量不大，冒泡排序是一个不错的选择。

4. **实时性要求不高的场景**：
   - 如果排序操作不是频繁执行，且对性能要求不高，可以考虑使用冒泡排序。

## 总结

冒泡排序是一种直观易懂的排序算法，适用于小规模的数据排序或者作为教学工具。由于其较差的性能（尤其是在处理大数据集时），在实际的生产环境中，往往会选择时间复杂度更优的排序算法（如快速排序、归并排序等）。但在某些特定场景下，冒泡排序仍然是一个有用的工具。
