# 最小生成树

## 介绍

最小生成树（Minimum Spanning Tree, MST） 是图论中的一个重要问题。给定一个无向加权图，最小生成树是该图的一个子图，它是一个树，包含所有节点且边的权重之和最小。
最小生成树在网络设计、交通规划等领域有广泛应用。

**常用的两种求解最小生成树的贪心算法是 `Prim` 算法 和 `Kruskal` 算法。**

> [!TIP] 算法说明
>
> 1. Prim 算法
>
> - 从任意一个节点开始，加入生成树。
> - 在已加入生成树的节点和未加入生成树的节点之间，选取权重最小的边，将对应的节点加入生成树。
> - 重复上述步骤，直到所有节点都被加入生成树。
>
> 2. Kruskal 算法
>
> - 将图中的所有边按照权重从小到大排序。
> - 依次检查每条边，若加入该边不会形成环，则将其加入生成树。
> - 重复上述步骤，直到生成树包含 $n-1$ 条边（$n$为节点数）。

## 代码

::: code-group
<<< ../../../src/greedy/minimum-spanning-tree.ts

<<< ../../../src/greedy/minimum-spanning-tree.test.ts
:::

## 源码

<SourceGroup/>

## 注意点

1. 连通性：图必须是连通的，才能生成 `MST`。如果输入图不是连通的，需要先检查连通性。
2. 边权重排序：`Kruskal` 算法需要对边进行排序，时间复杂度为 [$O(E log E)$](#o-e-log-e-——-kruskal-算法)
3. 优先队列：在 `Prim` 算法中使用优先队列（最小堆）可以优化性能，将复杂度降为 [$O(E log V)$](#o-e-log-v-——-prim-算法)

## 总结

最小生成树问题是贪心算法的重要应用，通过 `Prim` 和 `Kruskal` 算法可以高效解决该问题。两种算法各有适用场景，`Prim` 更适合稠密图，`Kruskal` 更适合稀疏图。在实现时需要注意数据结构的选择以优化性能。

## 拓展

#### `O(E log E)` —— `Kruskal` 算法

`Kruskal` 算法的核心在于对图的边集合进行排序并逐步构建最小生成树，以下是关键步骤：

1. 边的排序：

- 将图中 $E$ 条边按照权重升序排序。
- 使用标准排序算法（如快速排序或堆排序），其时间复杂度为 $O(E \log E)$。

1. 边的处理：

- 遍历排序后的边，逐一检查是否会形成环。
- 使用 **并查集（Union-Find）** 实现快速合并和环检测，单次操作的均摊时间复杂度为 `O(α(V))`，其中 `α(V)` 是反阿克曼函数，近似为一个非常小的常数。

总的时间复杂度为：$O(E \log E + E \cdot \alpha(V)) \approx O(E \log E)$ 因为 $log E$ 通常比 $α(V)$ 更大，故整体复杂度以 $O(E \log E)$ 表示。

#### `O(E log V)` —— `Prim` 算法

Prim 算法的核心在于通过优先队列（如最小堆）选择当前可访问的权重最小的边，以下是关键步骤：

1. 初始化最小堆：

- 使用堆存储所有可能加入生成树的边，堆中最多包含 $E$ 条边。

2. 每次选取最小边：

- 每次从堆中取出最小权重的边（堆顶元素），复杂度为 $O(\log E)$。
- 将新加入生成树的节点的邻边加入堆，复杂度与邻接边的数量成正比。

对于 $V$ 个节点，`Prim` 算法需要从堆中取出 $V$ 次最小边，并且更新堆的操作总共涉及 $E$ 条边，因此整体复杂度为：$O(V \cdot \log E + E \cdot \log E)$由于稀疏图中 $E \approx O(V)$，而稠密图中 $E \approx O(V^2)$，在稀疏图中可以将 $\log E \approx \log V$。最终的复杂度通常写为：$O(E \log V)$
