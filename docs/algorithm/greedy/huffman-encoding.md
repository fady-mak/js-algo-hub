# 哈夫曼编码

## 介绍

哈夫曼编码（Huffman Coding） 是一种贪心算法，用于基于字符出现的频率生成最优的前缀编码。它是一种可变长度编码方式，广泛应用于数据压缩（如文件压缩工具 ZIP 和媒体压缩格式 MP3 等）。

> [!TIP] 哈夫曼编码的核心思想
> 使用频率更高的字符分配较短的编码，而频率较低的字符分配较长的编码，从而实现整体编码长度的最小化。

---

> [!TIP] 算法步骤
>
> 1. 统计频率：统计每个字符在输入数据中的频率。
> 2. 构造优先队列：将每个字符及其频率作为节点插入优先队列。
> 3. 构造哈夫曼树：
>
> - 从优先队列中取出频率最小的两个节点，构造一个新节点，其频率为这两个节点频率之和。
> - 将新节点插回队列。
> - 重复此过程直到队列中只剩一个节点，作为根节点。
>
> 4. 生成编码：
>
> - 从根节点开始，根据左子树分配 0，右子树分配 1，生成每个字符的编码。
>
> 5. 编码和解码：
>
> - 使用生成的编码表对输入数据进行压缩。
> - 根据哈夫曼树对压缩后的数据进行解码。

## 代码

::: code-group
<<< ../../../src/greedy/huffman-encoding.ts

<<< ../../../src/greedy/huffman-encoding.test.ts
:::

## 源码

<SourceGroup/>

## 注意点

1. 前缀编码：

- 哈夫曼编码是一种前缀编码，生成的编码表不会产生歧义。例如，编码 `01` 不会是编码 `0101` 的前缀。

2. 频率与编码长度：

- 频率越高的字符编码越短，频率越低的字符编码越长。

3. 边界条件：

- 当输入中只有一个字符时，其编码为空字符串，因为无需进一步压缩。

4. 性能：

- 时间复杂度为$O(n \log n)$，构造树时需要进行多次排序。
- 空间复杂度为$O(n)$，用于存储哈夫曼树和编码表。

## 总结

哈夫曼编码是一种经典的贪心算法，能够根据字符频率构造最优编码表，从而有效地压缩数据。
它在文件压缩、网络传输、图像处理等领域有广泛应用，体现了贪心算法的高效性与实用性。
